<div class="container">
  <div class="row">
    <div class="col-12">
      <h2>Rotation Simulator</h2>
      <table class="table">
        <thead class="thead-default">
          <th>Sequence</th>
          <th>Time</th>
          <th>Skill/ Spell</th>
          <th>Ability</th>
          <th>Base Potency</th>
          <th>Self-multipliers</th>
          <th>Target multipliers</th>
          <th>Total potency</th>
        </thead>
        <tbody data-bind="foreach: timeline.actionsObserved">
          <tr>
            <td data-bind="text: sequence"></td>
            <td data-bind="text: timeSinceEncounter"></td>
            <td data-bind="text: name"></td>
            <td></td>
            <td data-bind="text: potency"></td>
            <td data-bind="text: multiplierText"></td>
            <td>0</td>
            <td data-bind="text: totalPotency"></td>
          </tr>
        </tbody>
      </table>

    </div>

    <div class="col-8">
      <form class="form">

        <div class="form-group row">
          <label class="col-sm-2 col-form-label">Skill/ Spell</label>
          <div class="col-8">
            <select data-bind="options: spells, optionsValue: 'id', optionsText: 'optionText', value: selectedSpell" class="form-control"></select>
          </div>

          <div class="col-2">
            <button class="btn btn-primary" data-bind="click: addSpellToQueue">Queue</button>
          </div>
        </div>

        <div class="form-group row">
          <label class="col-sm-2 col-form-label">Damage Multiplier Abilities</label>
          <div class="col-8">
            <select data-bind="options: damageMultiplierAbilities, optionsValue: 'id', optionsText: 'optionText', value: selectedDamageMultiplierAbility" class="form-control"></select>
          </div>

          <div class="col-2">
            <button class="btn btn-primary" data-bind="click: addDamageMultiplierToQueue">Queue</button>
          </div>
        </div>

      </form>
    </div>

    <div class="col-12 pt-5">
      <%= link_to "Back", dashboard_index_path, class: 'btn btn-secondary' %>
    </div>
  </div>
</div>

<script>
  // Timeline
  //
  //
  function Timeline() {
    var self = this;

    self.timeElapsed = 0;
    self.actionQueue = ko.observableArray([]);
    self.actionsObserved = ko.observableArray([]);
    self.effectsObserved = ko.observableArray([]);

    self.elapseTime = function(time) {
      self.timeElapsed = self.timeElapsed + time;
    }

    self.addToActionQueue = function(action) {
      self.actionQueue.push(action);
      self.observeActionUsage();
    }

    self.observeActionUsage = function(){
      // Clear current spells observed
      self.timeElapsed = 0;
      self.actionsObserved([]);
      self.effectsObserved([]);

      // Repopulate observed spells
      $.each(self.actionQueue(), function(indexInArray, action) {
        if (action instanceof Spell) {
          self.actionsObserved.push(new TimelineSpellObserver(self, action, indexInArray));
        } else if (action instanceof DamageMultiplierAbility) {
          self.actionsObserved.push(new TimelineEffectObserver(self, action, indexInArray));
          self.effectsObserved.push(new TimelineEffectObserver(self, action, indexInArray));
          // self.effectsObserved.push(new TimelineEffectObserver(self, action, indexInArray));
        }
      });
    };
  }

  // TimelineSpellObserver
  //
  // Keeps track of skills and spells that have been used
  function TimelineSpellObserver(timeline, spell, sequence) {
    const BASE_MULTIPLIER = 1.0;

    var self = this;

    self.timeline = timeline;
    self.spell = spell;
    self.sequence = sequence;

    // delegate common variables for table view
    self.name = spell.name;
    self.potency = spell.potency();

    self.timeSinceEncounter = ko.computed(function() {
      self.timeline.elapseTime(self.spell.castTime());
      return self.timeline.timeElapsed;
    });

    self.multiplier = calculateEffectiveMultipliers();
    self.multiplierText = ko.computed(function() {
      return `${self.multiplier.toFixed(2)}`;
    });
    self.totalPotency = ko.computed(function() {
      var total = self.potency * self.multiplier;
      return total.toFixed(2);
    });

    function calculateEffectiveMultipliers() {
      var totalMultiplier = BASE_MULTIPLIER;

      $.each(self.timeline.effectsObserved(), function(indexInArray, dmgAbility) {
        totalMultiplier = totalMultiplier * dmgAbility.multiplier;
      });

      return totalMultiplier;
    }
  }

  // TimelineEffectObserver
  //
  // Keeps track of abilities that have elapsed
  function TimelineEffectObserver(timeline, action, sequence) {
    var self = this;

    self.timeline = timeline;
    self.action = action;
    self.sequence = sequence;

    // delegate common variables for table view
    self.name = action.name;
    self.potency = null;
    self.totalPotency = null;

    self.multiplier = action.multiplier;
    self.multiplierText = ko.computed(function() {
      return `${self.multiplier.toFixed(2)}`;
    });

    self.timeSinceEncounter = ko.computed(function() {
      self.timeline.elapseTime(0);
      return self.timeline.timeElapsed;
    });
  }

  // Ability
  //
  //
  function Ability(obj) {
    var self = this;

    self.id = obj.id;
    self.name = obj.name;
  }

  // DamageMultiplierAbility
  //
  //
  function DamageMultiplierAbility(obj) {
    var self = this;

    self.id = obj.id;
    self.name = obj.name;
    self.multiplier = obj.multiplier;
    self.animationLock = obj.animationLock;

    self.optionText = ko.computed(function() {
      return `${self.name}: ${self.multiplier.toFixed(2)} multiplier`;
    });
  }

  // Spell
  //
  //
  function Spell(obj) {
    var self = this;

    self.id = obj.id;
    self.name = obj.name;
    self.potency = ko.observable(obj.potency);
    self.castTime = ko.observable(obj.castTime);
    self.animationLock = ko.observable(obj.animationLock);
    self.optionText = ko.computed(function() {
      return `${self.name}: ${self.potency()} potency`;
    });
  }

  // SimulationViewModel
  //
  //
  function SimulationViewModel() {
    var self = this;
    // Spells
    self.spells = ko.observableArray([]);
    self.selectedSpell = ko.observable();
    // Buffs
    self.damageMultiplierAbilities = ko.observableArray([]);
    self.selectedDamageMultiplierAbility = ko.observable();

    self.timeline = new Timeline();

    self.addSpellToQueue = function() {
      $.each(self.spells(), function(indexInArray, spell){
         if (spell.id.toString() === self.selectedSpell()) {
           self.timeline.addToActionQueue(spell);
         }
       });
    }

    self.addDamageMultiplierToQueue = function() {
      $.each(self.damageMultiplierAbilities(), function(indexInArray, ability){
         if (ability.id.toString() === self.selectedDamageMultiplierAbility()) {
           self.timeline.addToActionQueue(ability);
         }
       });
    }

    // TODO: read from database
    var spellObjects = [
      { id: "1", name: "Fire", potency: 180, castTime: 2.5 },
      { id: "2", name: "Blizzard", potency: 180, castTime: 2.5 },
      { id: "3", name: "Fire III", potency: 240, castTime: 3.5 },
      { id: "4", name: "Blizzard III", potency: 240, castTime: 3.5 }
    ];

    var damageMultiplierAbilities = [
      { id: "10", name: "Raging Strikes", multiplier: 1.2, duration: 20, cooldown: 180, animationLock: 1 },
      { id: "11", name: "Internal Release", multiplier: (1.5 * 1.1), duration: 15, cooldown: 60, animationLock: 1 }
    ]

    for (let spellObject of spellObjects) {
      self.spells.push(new Spell(spellObject));
    }

    for (let damageMultiplierAbility of damageMultiplierAbilities) {
      self.damageMultiplierAbilities.push(new DamageMultiplierAbility(damageMultiplierAbility));
    }
  }

  simulationViewModel = new SimulationViewModel();
  ko.applyBindings(simulationViewModel);
</script>
